> 목차는 [DB 목차](https://insanelysimple.tistory.com/category/database) 에 있습니다.



# [DB 4편] SQL Select 튜닝 정리



# Select 쿼리 튜닝

## Block I/O 최소화
- 하나의 테이블을 조회하는 것은 인덱스를 적절하게 잘 사용만 해도 큰 효과를 봅니다.
- 테이블 2개일 때 조인은 선행테이블 (기준 테이블) 이 몇 건을 읽어들였는지가 중요합니다. 왜냐하면 대부분의 조인은 Nested Loop (선행 테이블을 기준으로 한건씩 다른 테이블이랑 비교) 로 이루어지며, 앞의 선행테이블을 적게 읽을수록 후행테이블을 조인하는 횟수가 줄어들기 때문입니다.
    - 선행 테이블을 읽어들인 횟수는 실행계획을 통해 알 수 있습니다.
- 선행테이블, 후행 테이블 모두 적절한 인덱스를 선택해야하며, 인덱스가 없을 때는 생성하는 것이 좋습니다. 단, 해당 인덱스를 생성 함으로써 미치는 영향도가 어느정도인지는 확인이 필요합니다.
- 또는 테이블이 3개 이상일 때, 조인순서를 변경해서 Block I/O 를 줄일 수 있는지도 체크해야합니다.

## Random I/O 최소화

- 테이블의 데이터를 조회할 때는, 특정 데이터 블록에 접근해서 데이터를 조회합니다.
- 범위 데이터를 조회할 때, 하나의 데이터 블록만 접근해서 범위 데이터를 조회하는 것이 여러 데이터 블록을 접근해서 범위 데이터를 조회하는 것보다 빠릅니다.
- 데이터가 저장될 때는, 특정 규칙없이 데이터 블록에 저장이 됩니다. 데이터가 저장될 때, 연관있는 데이터끼리 데이터 블록에 저장한다면 성능이 좋아질 것 입니다. 보통 연관있는 데이터(날짜가 같은) 를 서로 많이 조회하기 때문입니다.

## Random I/O 최소화 방법

- 클러스터드 인덱스
    - 프라이머리 키 순서로 데이터가 정렬되어 디스크에 저장됩니다. (즉, 비슷한 값을 최대한 모아서 저장)
- 파티션
    - 특정 키를 기준으로 파티셔닝 (물리적으로 나눔) 합니다. 예를 들면, 테이블의 날짜를 기준으로 파티셔닝을 하면 특정 날짜는 특정 물리 저장소에만 저장이 될 것 입니다.
- 커버링 인덱스
    - 데이터 블록을 접근하지않고 인덱스만 조회해서 데이터를 가져오는 방식입니다.
    - 커버링 인덱스 글 참고해서 넣어주기

# Reference
- [https://12bme.tistory.com/204?category=749950](https://12bme.tistory.com/204?category=749950)